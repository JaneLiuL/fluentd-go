package plugin

import (
	"log"
	"regexp"
	"sync"
	"time"
)

// FilterPlugin 过滤插件接口
type FilterPlugin interface {
	Start()
	Stop()
}

// BaseFilter 过滤插件基类
type BaseFilter struct {
	inputQueue  *Queue
	outputQueue *Queue
	matchTags   []string
	running     bool
	mu          sync.Mutex
	wg          sync.WaitGroup
}

/**
type FilterRule struct {
	Type    string            `yaml:"type"`
	Tag     string            `yaml:"tag"`
	Match   map[string]string `yaml:"match"`
	Exclude map[string]string `yaml:"exclude"`
}

func (f *FilterRule) Evaluate(record map[string]interface{}) bool {
	if len(f.Match) > 0 {
		matchResult := f.evaluateMatchs(f.Match, record)
		if !matchResult {
			if f.Type == "match" {
				return false
			}
		}
	}
	if len(f.Exclude) > 0 {
		excludeResult := f.evaluateMatchs(f.Exclude, record)
		if excludeResult {
			if f.Type == "exclude" {
				return false
			}
		}
	}
	return true
}

func (f *FilterRule) evaluateMatchs(matchers map[string]string, record map[string]interface{}) bool {
	for key, pattern := range matchers {
		value, exists := record[key]
		if !exists {
			return false
		}
		operator, target := parseOperator(pattern)
		if !f.checkCondition(value, operator, target) {
			return false
		}
	}
	return true
}

func parseOperator(pattern string) (string, string) {
	operators := []string{">=", "<=", "!~", "~", "!=", ">", "<", "="}

	for _, op := range operators {
		if len(pattern) > len(op) && pattern[:len(op)] == op {
			return op, pattern[len(op):]
		}
	}
	return "=", pattern
}

func (f *FilterRule) checkCondition(value interface{}, operator, target string) bool {

	switch v := value.(type) {
	case string:
		return f.checkStringCondition(v, operator, target)
	default:
		return false
	}
}

func (f *FilterRule) checkStringCondition(value, operator, target string) bool {
	switch operator {
	case "=":
		return value == target
	case "!=":
		return value != target
	case "~":
		matched, _ := regexp.MatchString(target, value)
		return matched
	case "!~":
		matched, _ := regexp.MatchString(target, value)
		return !matched
	case "in":
		for _, t := range splitTarget(target) {
			if value == t {
				return true
			}
		}
		return false
	default:
		return false
	}
}

func splitTarget(target string) []string {
	var result []string
	start := 0
	inQuotes := false

	for i, c := range target {
		if c == '"' {
			inQuotes = !inQuotes
		} else if c == ',' && !inQuotes {
			if i > start {
				result = append(result, trimQuotes(target[start:i]))
			}
			start = i + 1
		}
	}

	if start < len(target) {
		result = append(result, trimQuotes(target[start:]))
	}

	return result
}

// 去除引号
func trimQuotes(s string) string {
	if len(s) >= 2 && s[0] == '"' && s[len(s)-1] == '"' {
		return s[1 : len(s)-1]
	}
	return s
}
**/
// NewBaseFilter 创建一个新的基础过滤插件
func NewBaseFilter(inputQueue, outputQueue *Queue, matchTags []string) *BaseFilter {
	return &BaseFilter{
		inputQueue:  inputQueue,
		outputQueue: outputQueue,
		matchTags:   matchTags,
		running:     false,
	}
}

// IsRunning 检查插件是否在运行
func (f *BaseFilter) IsRunning() bool {
	f.mu.Lock()
	defer f.mu.Unlock()
	return f.running
}

// SetRunning 设置插件运行状态
func (f *BaseFilter) SetRunning(running bool) {
	f.mu.Lock()
	defer f.mu.Unlock()
	f.running = running
}

// Matches 检查事件标签是否匹配
func (f *BaseFilter) Matches(tag string) bool {
	for _, pattern := range f.matchTags {
		// 简单的通配符匹配，*匹配任意字符
		if pattern == "*" {
			return true
		}
		if pattern[len(pattern)-1] == '*' && len(tag) >= len(pattern)-1 &&
			tag[:len(pattern)-1] == pattern[:len(pattern)-1] {
			return true
		}
		if tag == pattern {
			return true
		}
	}
	return false
}

// GrepFilter 基于正则表达式过滤事件
type GrepFilter struct {
	*BaseFilter
	key     string
	pattern *regexp.Regexp
	exclude bool
}

// NewGrepFilter 创建一个新的Grep过滤插件
func NewGrepFilter(inputQueue, outputQueue *Queue, matchTags []string, key, pattern string, exclude bool) *GrepFilter {
	return &GrepFilter{
		BaseFilter: NewBaseFilter(inputQueue, outputQueue, matchTags),
		key:        key,
		pattern:    regexp.MustCompile(pattern),
		exclude:    exclude,
	}
}

// Filter 执行过滤操作
func (g *GrepFilter) Filter(event *Event) *Event {
	value, ok := event.Record[g.key].(string)
	if !ok {
		// 如果字段不存在或不是字符串，根据exclude决定是否保留
		if g.exclude {
			return event
		}
		return nil
	}

	match := g.pattern.MatchString(value)

	// 根据exclude决定是否保留匹配的事件
	if (match && !g.exclude) || (!match && g.exclude) {
		return event
	}

	return nil
}

// Start 启动过滤插件
func (g *GrepFilter) Start() {
	if g.IsRunning() {
		return
	}

	g.SetRunning(true)
	g.BaseFilter.wg.Add(1)

	go func() {
		defer g.BaseFilter.wg.Done()
		log.Println("Starting GrepFilter")

		for g.IsRunning() {
			event, ok := g.inputQueue.Get()
			if !ok {
				// 队列已关闭或无数据，短暂休眠
				time.Sleep(100 * time.Millisecond)
				continue
			}

			if g.Matches(event.Tag) {
				filteredEvent := g.Filter(event)
				if filteredEvent != nil {
					g.outputQueue.Put(filteredEvent)
				}
			} else {
				// 不匹配的事件直接传递
				g.outputQueue.Put(event)
			}
		}
	}()
}

// Stop 停止过滤插件
func (g *GrepFilter) Stop() {
	if !g.IsRunning() {
		return
	}

	g.SetRunning(false)
	g.BaseFilter.wg.Wait()
	log.Println("Stopped GrepFilter")
}

// RecordTransformerFilter 用于修改事件记录的过滤插件
type RecordTransformerFilter struct {
	*BaseFilter
	addFields    map[string]interface{}
	removeFields []string
}

// NewRecordTransformerFilter 创建一个新的记录转换过滤插件
func NewRecordTransformerFilter(inputQueue, outputQueue *Queue, matchTags []string, addFields map[string]interface{}, removeFields []string) *RecordTransformerFilter {
	return &RecordTransformerFilter{
		BaseFilter:   NewBaseFilter(inputQueue, outputQueue, matchTags),
		addFields:    addFields,
		removeFields: removeFields,
	}
}

// Filter 执行记录转换操作
func (r *RecordTransformerFilter) Filter(event *Event) *Event {
	// 添加字段
	for key, value := range r.addFields {
		event.Record[key] = value
	}

	// 移除字段
	for _, key := range r.removeFields {
		delete(event.Record, key)
	}

	return event
}

// Start 启动过滤插件
func (r *RecordTransformerFilter) Start() {
	if r.IsRunning() {
		return
	}

	r.SetRunning(true)
	r.BaseFilter.wg.Add(1)

	go func() {
		defer r.BaseFilter.wg.Done()
		log.Println("Starting RecordTransformerFilter")

		for r.IsRunning() {
			event, ok := r.inputQueue.Get()
			if !ok {
				// 队列已关闭或无数据，短暂休眠
				time.Sleep(100 * time.Millisecond)
				continue
			}

			if r.Matches(event.Tag) {
				transformedEvent := r.Filter(event)
				if transformedEvent != nil {
					r.outputQueue.Put(transformedEvent)
				}
			} else {
				// 不匹配的事件直接传递
				r.outputQueue.Put(event)
			}
		}
	}()
}

// Stop 停止过滤插件
func (r *RecordTransformerFilter) Stop() {
	if !r.IsRunning() {
		return
	}

	r.SetRunning(false)
	r.BaseFilter.wg.Wait()
	log.Println("Stopped RecordTransformerFilter")
}
